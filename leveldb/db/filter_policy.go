package leveldb

// Copyright (c) 2020 Bert Young. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// A database can be configured with a custom FilterPolicy object.
// This object is responsible for creating a small filter from a set
// of keys.  These filters are stored in leveldb and are consulted
// automatically by leveldb to decide whether or not to read some
// information from disk. In many cases, a filter can cut down the
// number of disk seeks form a handful to a single disk seek per
// DB::Get() call.
//
// Most people will want to use the builtin bloom filter support (see
// NewBloomFilterPolicy() below).

import (
	"hash"
	"hash/fnv"
)

type FilterPolicy interface {
	// Return the name of this policy.  Note that if the filter encoding
	// changes in an incompatible way, the name returned by this method
	// must be changed.  Otherwise, old incompatible filters may be
	// passed to methods of this type.
	Name() string

	// keys contains a list of keys (potentially with duplicates)
	// that are ordered according to the user supplied comparator.
	// Append a filter that summarizes keys to *dst.
	//
	// Warning: do not change the initial contents of *dst.  Instead,
	// append the newly constructed filter to *dst.
	CreateFilter(keys [][]byte, dst *[]byte)

	// "filter" contains the data appended by a preceding call to
	// CreateFilter() on this class.  This method must return true if
	// the key was in the list of keys passed to CreateFilter().
	// This method may return true or false if the key was not on the
	// list, but it should aim to return false with a high probability.
	KeyMayMatch(key, filter []byte) bool
}

// Return a new filter policy that uses a bloom filter with approximately
// the specified number of bits per key.  A good value for bits_per_key
// is 10, which yields a filter with ~ 1% false positive rate.
//
// Callers must delete the result after any database that is using the
// result has been closed.
//
// Note: if you are using a custom comparator that ignores some parts
// of the keys being compared, you must not use NewBloomFilterPolicy()
// and must provide your own FilterPolicy that also ignores the
// corresponding parts of the keys.  For example, if the comparator
// ignores trailing spaces, it would be incorrect to use a
// FilterPolicy (like NewBloomFilterPolicy) that does not ignore
// trailing spaces in keys.
func NewBloomFilterPolicy(bitsPerKey int) FilterPolicy {
	bfp := &bloomFilterPolicy{}
	bfp.bitsPerKey = bitsPerKey
	bfp.hash = fnv.New32()

	k := int(float64(bitsPerKey) * 0.69) // 0.69 =~ ln(2)
	if k < 1 {
		k = 1
	} else if k > 30 {
		k = 30
	}

	bfp.k = k
	return bfp
}

type bloomFilterPolicy struct {
	bitsPerKey int
	k          int
	hash       hash.Hash32
}

func (bfp *bloomFilterPolicy) Name() string {
	return "leveldb.BuiltinBloomFilter2"
}

func (bfp *bloomFilterPolicy) CreateFilter(keys [][]byte, dest *[]byte) {
	// Compute bloom filter size (in both bits and bytes)
	bits := len(keys) * bfp.bitsPerKey

	// For small n, we can see a very high false positive rate.  Fix it
	// by enforcing a minimum bloom filter length.
	if bits < 64 {
		bits = 64
	}

	bytes := (bits + 7) / 8
	bits = bytes * 8

	var dst []byte
	if dest != nil {
		dst = (*dest)[:]
	} else {
		dst = make([]byte, 0)
	}

	initSize := len(dst)
	dst = append(dst, make([]byte, bytes)...)
	dst = append(dst, byte(bfp.k)) // Remember # of probes in filter
	arr := dst[initSize:]

	for i := 0; i < len(keys); i++ {
		k := keys[i]
		bfp.hash.Reset()
		bfp.hash.Write(k)
		h := bfp.hash.Sum32()
		// Use double-hashing to generate a sequence of hash values.
		// See analysis in [Kirsch,Mitzenmacher 2006].

		delta := (h >> 17) | (h << 15)
		for j := 0; j < bfp.k; j++ {
			bitpos := h % uint32(bits)
			arr[bitpos/8] |= (1 << (bitpos % 8))
			h += delta
		}
	}

	*dest = dst
}

func (bfp *bloomFilterPolicy) KeyMayMatch(key, filter []byte) bool {
	if len(filter) < 2 {
		return false
	}

	// Use the encoded k so that we can read filters generated by
	// bloom filters created using different parameters.
	k := int(filter[len(filter)-1])
	if k > 30 {
		// Reserved for potentially new encodings for short bloom filters.
		// Consider it a match.
		return true
	}

	bfp.hash.Reset()
	bfp.hash.Write(key)
	h := bfp.hash.Sum32()
	delta := (h >> 17) | (h << 15)
	bits := (len(filter) - 1) * 8
	for j := 0; j < k; j++ {
		bitpos := h % uint32(bits)
		if (filter[bitpos/8] & (1 << (bitpos % 8))) == 0 {
			return false
		}
		h += delta
	}

	return true
}
